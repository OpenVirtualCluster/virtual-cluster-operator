// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1alpha1

type BackingStore struct {
	// Database defines that a database backend should be used as the backend for the
	// virtual cluster. This uses a project called kine under the hood which is a shim
	// for bridging Kubernetes and relational databases.
	Database *Database `json:"database,omitempty" yaml:"database,omitempty" mapstructure:"database,omitempty"`

	// Etcd defines that etcd should be used as the backend for the virtual cluster
	Etcd *Etcd `json:"etcd,omitempty" yaml:"etcd,omitempty" mapstructure:"etcd,omitempty"`
}

type CentralAdmission struct {
	// MutatingWebhooks are mutating webhooks that should be enforced in the virtual
	// cluster
	MutatingWebhooks []MutatingWebhookConfiguration `json:"mutatingWebhooks,omitempty" yaml:"mutatingWebhooks,omitempty" mapstructure:"mutatingWebhooks,omitempty"`

	// ValidatingWebhooks are validating webhooks that should be enforced in the
	// virtual cluster
	ValidatingWebhooks []ValidatingWebhookConfiguration `json:"validatingWebhooks,omitempty" yaml:"validatingWebhooks,omitempty" mapstructure:"validatingWebhooks,omitempty"`
}

type ControlPlane struct {
	// Advanced holds additional configuration for the vCluster control plane.
	Advanced *ControlPlaneAdvanced `json:"advanced,omitempty" yaml:"advanced,omitempty" mapstructure:"advanced,omitempty"`

	// BackingStore defines which backing store to use for virtual cluster. If not
	// defined will use embedded database as a default backing store.
	BackingStore *BackingStore `json:"backingStore,omitempty" yaml:"backingStore,omitempty" mapstructure:"backingStore,omitempty"`

	// CoreDNS defines everything related to the coredns that is deployed and used
	// within the vCluster.
	Coredns *CoreDNS `json:"coredns,omitempty" yaml:"coredns,omitempty" mapstructure:"coredns,omitempty"`

	// Distro holds virtual cluster related distro options. A distro cannot be changed
	// after vCluster is deployed.
	Distro *Distro `json:"distro,omitempty" yaml:"distro,omitempty" mapstructure:"distro,omitempty"`

	// HostPathMapper defines if vCluster should rewrite host paths.
	HostPathMapper *HostPathMapper `json:"hostPathMapper,omitempty" yaml:"hostPathMapper,omitempty" mapstructure:"hostPathMapper,omitempty"`

	// Ingress defines options for vCluster ingress deployed by Helm.
	Ingress *ControlPlaneIngress `json:"ingress,omitempty" yaml:"ingress,omitempty" mapstructure:"ingress,omitempty"`

	// Proxy defines options for the virtual cluster control plane proxy that is used
	// to do authentication and intercept requests.
	Proxy *ControlPlaneProxy `json:"proxy,omitempty" yaml:"proxy,omitempty" mapstructure:"proxy,omitempty"`

	// Service defines options for vCluster service deployed by Helm.
	Service *ControlPlaneService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceMonitor can be used to automatically create a service monitor for
	// vCluster deployment itself.
	ServiceMonitor *ServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty" mapstructure:"serviceMonitor,omitempty"`

	// StatefulSet defines options for vCluster statefulSet deployed by Helm.
	StatefulSet *ControlPlaneStatefulSet `json:"statefulSet,omitempty" yaml:"statefulSet,omitempty" mapstructure:"statefulSet,omitempty"`
}

type ControlPlaneAdvanced struct {
	// DefaultImageRegistry will be used as a prefix for all internal images deployed
	// by vCluster or Helm. This makes it easy to
	// upload all required vCluster images to a single private repository and set this
	// value. Workload images are not affected by this.
	DefaultImageRegistry *string `json:"defaultImageRegistry,omitempty" yaml:"defaultImageRegistry,omitempty" mapstructure:"defaultImageRegistry,omitempty"`

	// GlobalMetadata is metadata that will be added to all resources deployed by
	// Helm.
	GlobalMetadata *ControlPlaneGlobalMetadata `json:"globalMetadata,omitempty" yaml:"globalMetadata,omitempty" mapstructure:"globalMetadata,omitempty"`

	// HeadlessService specifies options for the headless service used for the
	// vCluster StatefulSet.
	HeadlessService *ControlPlaneHeadlessService `json:"headlessService,omitempty" yaml:"headlessService,omitempty" mapstructure:"headlessService,omitempty"`

	// ServiceAccount specifies options for the vCluster control plane service
	// account.
	ServiceAccount *ControlPlaneServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// VirtualScheduler defines if a scheduler should be used within the virtual
	// cluster or the scheduling decision for workloads will be made by the host
	// cluster.
	VirtualScheduler *EnableSwitch `json:"virtualScheduler,omitempty" yaml:"virtualScheduler,omitempty" mapstructure:"virtualScheduler,omitempty"`

	// WorkloadServiceAccount specifies options for the service account that will be
	// used for the workloads that run within the virtual cluster.
	WorkloadServiceAccount *ControlPlaneWorkloadServiceAccount `json:"workloadServiceAccount,omitempty" yaml:"workloadServiceAccount,omitempty" mapstructure:"workloadServiceAccount,omitempty"`
}

type ControlPlaneGlobalMetadata struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneGlobalMetadataAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneGlobalMetadataAnnotations map[string]string

type ControlPlaneHeadlessService struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneHeadlessServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneHeadlessServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneHeadlessServiceAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneHeadlessServiceLabels map[string]string

type ControlPlaneHighAvailability struct {
	// LeaseDuration is the time to lease for the leader.
	LeaseDuration *int `json:"leaseDuration,omitempty" yaml:"leaseDuration,omitempty" mapstructure:"leaseDuration,omitempty"`

	// RenewDeadline is the deadline to renew a lease for the leader.
	RenewDeadline *int `json:"renewDeadline,omitempty" yaml:"renewDeadline,omitempty" mapstructure:"renewDeadline,omitempty"`

	// Replicas is the amount of replicas to use for the statefulSet.
	Replicas *int `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// RetryPeriod is the time until a replica will retry to get a lease.
	RetryPeriod *int `json:"retryPeriod,omitempty" yaml:"retryPeriod,omitempty" mapstructure:"retryPeriod,omitempty"`
}

type ControlPlaneIngress struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneIngressAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the control plane ingress should be enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Host is the host where vCluster will be reachable
	Host *string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneIngressLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// PathType is the path type of the ingress
	PathType *string `json:"pathType,omitempty" yaml:"pathType,omitempty" mapstructure:"pathType,omitempty"`

	// Spec allows you to configure extra ingress options.
	Spec ControlPlaneIngressSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneIngressAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneIngressLabels map[string]string

// Spec allows you to configure extra ingress options.
type ControlPlaneIngressSpec map[string]interface{}

type ControlPlanePersistence struct {
	// AddVolumeMounts defines extra volume mounts for the container
	AddVolumeMounts []VolumeMount `json:"addVolumeMounts,omitempty" yaml:"addVolumeMounts,omitempty" mapstructure:"addVolumeMounts,omitempty"`

	// AddVolumes defines extra volumes for the pod
	AddVolumes []ControlPlanePersistenceAddVolumesElem `json:"addVolumes,omitempty" yaml:"addVolumes,omitempty" mapstructure:"addVolumes,omitempty"`

	// VolumeClaim can be used to configure the persistent volume claim.
	VolumeClaim *VolumeClaim `json:"volumeClaim,omitempty" yaml:"volumeClaim,omitempty" mapstructure:"volumeClaim,omitempty"`

	// VolumeClaimTemplates defines the volumeClaimTemplates for the statefulSet
	VolumeClaimTemplates []ControlPlanePersistenceVolumeClaimTemplatesElem `json:"volumeClaimTemplates,omitempty" yaml:"volumeClaimTemplates,omitempty" mapstructure:"volumeClaimTemplates,omitempty"`
}

type ControlPlanePersistenceAddVolumesElem map[string]interface{}

type ControlPlanePersistenceVolumeClaimTemplatesElem map[string]interface{}

type ControlPlaneProbes struct {
	// LivenessProbe specifies if the liveness probe for the container should be
	// enabled
	LivenessProbe *EnableSwitch `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// ReadinessProbe specifies if the readiness probe for the container should be
	// enabled
	ReadinessProbe *EnableSwitch `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// StartupProbe specifies if the startup probe for the container should be enabled
	StartupProbe *EnableSwitch `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`
}

type ControlPlaneProxy struct {
	// BindAddress under which vCluster will expose the proxy.
	BindAddress *string `json:"bindAddress,omitempty" yaml:"bindAddress,omitempty" mapstructure:"bindAddress,omitempty"`

	// ExtraSANs are extra hostnames to sign the vCluster proxy certificate for.
	ExtraSANs []string `json:"extraSANs,omitempty" yaml:"extraSANs,omitempty" mapstructure:"extraSANs,omitempty"`

	// Port under which vCluster will expose the proxy. Changing port is currently not
	// supported.
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

type ControlPlaneScheduling struct {
	// Affinity is the affinity to apply to the pod.
	Affinity ControlPlaneSchedulingAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// NodeSelector is the node selector to apply to the pod.
	NodeSelector ControlPlaneSchedulingNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// PodManagementPolicy is the statefulSet pod management policy.
	PodManagementPolicy *string `json:"podManagementPolicy,omitempty" yaml:"podManagementPolicy,omitempty" mapstructure:"podManagementPolicy,omitempty"`

	// PriorityClassName is the priority class name for the the pod.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// Tolerations are the tolerations to apply to the pod.
	Tolerations []ControlPlaneSchedulingTolerationsElem `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// TopologySpreadConstraints are the topology spread constraints for the pod.
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`
}

// Affinity is the affinity to apply to the pod.
type ControlPlaneSchedulingAffinity map[string]interface{}

// NodeSelector is the node selector to apply to the pod.
type ControlPlaneSchedulingNodeSelector map[string]interface{}

type ControlPlaneSchedulingTolerationsElem map[string]interface{}

type ControlPlaneSecurity struct {
	// ContainerSecurityContext specifies security context options on the container
	// level.
	ContainerSecurityContext ControlPlaneSecurityContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// PodSecurityContext specifies security context options on the pod level.
	PodSecurityContext ControlPlaneSecurityPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`
}

// ContainerSecurityContext specifies security context options on the container
// level.
type ControlPlaneSecurityContainerSecurityContext map[string]interface{}

// PodSecurityContext specifies security context options on the pod level.
type ControlPlaneSecurityPodSecurityContext map[string]interface{}

type ControlPlaneService struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the control plane service should be enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// HTTPSNodePort is the node port where https is exposed. Defaults to 0.
	HttpsNodePort *int `json:"httpsNodePort,omitempty" yaml:"httpsNodePort,omitempty" mapstructure:"httpsNodePort,omitempty"`

	// KubeletNodePort is the node port where the fake kubelet is exposed. Defaults to
	// 0.
	KubeletNodePort *int `json:"kubeletNodePort,omitempty" yaml:"kubeletNodePort,omitempty" mapstructure:"kubeletNodePort,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Spec allows you to configure extra service options.
	Spec ControlPlaneServiceSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`
}

type ControlPlaneServiceAccount struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled specifies if the service account should get deployed.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ImagePullSecrets defines extra image pull secrets for the service account.
	ImagePullSecrets []ImagePullSecretName `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneServiceAccountLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name specifies what name to use for the service account.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneServiceAccountAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneServiceAccountLabels map[string]string

// Annotations are extra annotations for this resource.
type ControlPlaneServiceAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneServiceLabels map[string]string

// Spec allows you to configure extra service options.
type ControlPlaneServiceSpec map[string]interface{}

type ControlPlaneStatefulSet struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneStatefulSetAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Args allows you to override the main arguments.
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command allows you to override the main command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// EnableServiceLinks for the StatefulSet pod
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Env are additional environment variables for the statefulSet container.
	Env []ControlPlaneStatefulSetEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// HighAvailability holds options related to high availability.
	HighAvailability *ControlPlaneHighAvailability `json:"highAvailability,omitempty" yaml:"highAvailability,omitempty" mapstructure:"highAvailability,omitempty"`

	// Image is the image for the controlPlane statefulSet container
	Image *StatefulSetImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the policy how to pull the image.
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneStatefulSetLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Persistence defines options around persistence for the statefulSet.
	Persistence *ControlPlanePersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Additional labels or annotations for the statefulSet pods.
	Pods *LabelsAndAnnotations `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// Probes enables or disables the main container probes.
	Probes *ControlPlaneProbes `json:"probes,omitempty" yaml:"probes,omitempty" mapstructure:"probes,omitempty"`

	// Resources are the resource requests and limits for the statefulSet container.
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scheduling holds options related to scheduling.
	Scheduling *ControlPlaneScheduling `json:"scheduling,omitempty" yaml:"scheduling,omitempty" mapstructure:"scheduling,omitempty"`

	// Security defines pod or container security context.
	Security *ControlPlaneSecurity `json:"security,omitempty" yaml:"security,omitempty" mapstructure:"security,omitempty"`

	// WorkingDir specifies in what folder the main process should get started.
	WorkingDir *string `json:"workingDir,omitempty" yaml:"workingDir,omitempty" mapstructure:"workingDir,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneStatefulSetAnnotations map[string]string

type ControlPlaneStatefulSetEnvElem map[string]interface{}

// Labels are extra labels for this resource.
type ControlPlaneStatefulSetLabels map[string]string

type ControlPlaneWorkloadServiceAccount struct {
	// Annotations are extra annotations for this resource.
	Annotations ControlPlaneWorkloadServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled specifies if the service account for the workloads should get deployed.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ImagePullSecrets defines extra image pull secrets for the workload service
	// account.
	ImagePullSecrets []ImagePullSecretName `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Labels are extra labels for this resource.
	Labels ControlPlaneWorkloadServiceAccountLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name specifies what name to use for the service account for the virtual cluster
	// workloads.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Annotations are extra annotations for this resource.
type ControlPlaneWorkloadServiceAccountAnnotations map[string]string

// Labels are extra labels for this resource.
type ControlPlaneWorkloadServiceAccountLabels map[string]string

type CoreDNS struct {
	// Deployment holds extra options for the coredns deployment deployed within the
	// virtual cluster
	Deployment *CoreDNSDeployment `json:"deployment,omitempty" yaml:"deployment,omitempty" mapstructure:"deployment,omitempty"`

	// Embedded defines if vCluster will start the embedded coredns service within the
	// control-plane and not as a separate deployment. This is a PRO feature.
	Embedded *bool `json:"embedded,omitempty" yaml:"embedded,omitempty" mapstructure:"embedded,omitempty"`

	// Enabled defines if coredns is enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// OverwriteConfig can be used to overwrite the coredns config
	OverwriteConfig *string `json:"overwriteConfig,omitempty" yaml:"overwriteConfig,omitempty" mapstructure:"overwriteConfig,omitempty"`

	// OverwriteManifests can be used to overwrite the coredns manifests used to
	// deploy coredns
	OverwriteManifests *string `json:"overwriteManifests,omitempty" yaml:"overwriteManifests,omitempty" mapstructure:"overwriteManifests,omitempty"`

	// PriorityClassName specifies the priority class name for the CoreDNS pods.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// Service holds extra options for the coredns service deployed within the virtual
	// cluster
	Service *CoreDNSService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

type CoreDNSDeployment struct {
	// Annotations are extra annotations for this resource.
	Annotations CoreDNSDeploymentAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Image is the coredns image to use
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Labels are extra labels for this resource.
	Labels CoreDNSDeploymentLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// NodeSelector is the node selector to use for coredns.
	NodeSelector CoreDNSDeploymentNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Pods is additional metadata for the coredns pods.
	Pods *LabelsAndAnnotations `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// Replicas is the amount of coredns pods to run.
	Replicas *int `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// Resources are the desired resources for coredns.
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`
}

// Annotations are extra annotations for this resource.
type CoreDNSDeploymentAnnotations map[string]string

// Labels are extra labels for this resource.
type CoreDNSDeploymentLabels map[string]string

// NodeSelector is the node selector to use for coredns.
type CoreDNSDeploymentNodeSelector map[string]string

type CoreDNSService struct {
	// Annotations are extra annotations for this resource.
	Annotations CoreDNSServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels are extra labels for this resource.
	Labels CoreDNSServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Spec holds extra options for the coredns service
	Spec CoreDNSServiceSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`
}

// Annotations are extra annotations for this resource.
type CoreDNSServiceAnnotations map[string]string

// Labels are extra labels for this resource.
type CoreDNSServiceLabels map[string]string

// Spec holds extra options for the coredns service
type CoreDNSServiceSpec map[string]interface{}

type Database struct {
	// Embedded defines that an embedded database (sqlite) should be used as the
	// backend for the virtual cluster
	Embedded *DatabaseKine `json:"embedded,omitempty" yaml:"embedded,omitempty" mapstructure:"embedded,omitempty"`

	// External defines that an external database should be used as the backend for
	// the virtual cluster
	External *DatabaseKine `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`
}

type DatabaseKine struct {
	// CaFile is the ca file to use for the database. This is optional.
	CaFile *string `json:"caFile,omitempty" yaml:"caFile,omitempty" mapstructure:"caFile,omitempty"`

	// CertFile is the cert file to use for the database. This is optional.
	CertFile *string `json:"certFile,omitempty" yaml:"certFile,omitempty" mapstructure:"certFile,omitempty"`

	// DataSource is the kine dataSource to use for the database. This depends on the
	// database format.
	// This is optional for the embedded database. Examples:
	// * mysql: mysql://username:password@tcp(hostname:3306)/k3s
	// * postgres: postgres://username:password@hostname:5432/k3s
	DataSource *string `json:"dataSource,omitempty" yaml:"dataSource,omitempty" mapstructure:"dataSource,omitempty"`

	// Enabled defines if the database should be used.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// KeyFile is the key file to use for the database. This is optional.
	KeyFile *string `json:"keyFile,omitempty" yaml:"keyFile,omitempty" mapstructure:"keyFile,omitempty"`
}

type DenyRule struct {
	// ExcludedUsers describe a list of users for which the checks will be skipped.
	// Impersonation attempts on these users will still be subjected to the checks.
	ExcludedUsers []string `json:"excludedUsers,omitempty" yaml:"excludedUsers,omitempty" mapstructure:"excludedUsers,omitempty"`

	// The name of the check.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace describe a list of namespaces that will be affected by the check.
	// An empty list means that all namespaces will be affected.
	// In case of ClusterScoped rules, only the Namespace resource is affected.
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// Rules describes on which verbs and on what resources/subresources the webhook
	// is enforced.
	// The webhook is enforced if it matches any Rule.
	// The version of the request must match the rule version exactly. Equivalent
	// matching is not supported.
	Rules []RuleWithVerbs `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`
}

type Distro struct {
	// EKS holds eks relevant configuration.
	Eks *DistroK8S `json:"eks,omitempty" yaml:"eks,omitempty" mapstructure:"eks,omitempty"`

	// K0S holds k0s relevant configuration.
	K0S *DistroK0S `json:"k0s,omitempty" yaml:"k0s,omitempty" mapstructure:"k0s,omitempty"`

	// K3S holds K3s relevant configuration.
	K3S *DistroK3S `json:"k3s,omitempty" yaml:"k3s,omitempty" mapstructure:"k3s,omitempty"`

	// K8S holds K8s relevant configuration.
	K8S *DistroK8S `json:"k8s,omitempty" yaml:"k8s,omitempty" mapstructure:"k8s,omitempty"`
}

type DistroContainer struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`
}

type DistroContainerEnabled struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enabled signals this container should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`
}

type DistroK0S struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Config allows you to override the k0s config passed to the k0s binary.
	Config *string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Enabled specifies if the k0s distro should be enabled. Only one distro can be
	// enabled at the same time.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables to use for the main container and NOT the
	// init container.
	Env []DistroK0SEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Resources for the distro init container
	Resources DistroK0SResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Security options can be used for the distro init container
	SecurityContext DistroK0SSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`
}

type DistroK0SEnvElem map[string]interface{}

// Resources for the distro init container
type DistroK0SResources map[string]interface{}

// Security options can be used for the distro init container
type DistroK0SSecurityContext map[string]interface{}

type DistroK3S struct {
	// Command is the command to start the distro binary. This will override the
	// existing command.
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enabled specifies if the K3s distro should be enabled. Only one distro can be
	// enabled at the same time.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables to use for the main container and NOT the
	// init container.
	Env []DistroK3SEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// ExtraArgs are additional arguments to pass to the distro binary.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// Image is the distro image
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the distro image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Resources for the distro init container
	Resources DistroK3SResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Security options can be used for the distro init container
	SecurityContext DistroK3SSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Token is the K3s token to use. If empty, vCluster will choose one.
	Token *string `json:"token,omitempty" yaml:"token,omitempty" mapstructure:"token,omitempty"`
}

type DistroK3SEnvElem map[string]interface{}

// Resources for the distro init container
type DistroK3SResources map[string]interface{}

// Security options can be used for the distro init container
type DistroK3SSecurityContext map[string]interface{}

type DistroK8S struct {
	// APIServer holds configuration specific to starting the api server.
	ApiServer *DistroContainerEnabled `json:"apiServer,omitempty" yaml:"apiServer,omitempty" mapstructure:"apiServer,omitempty"`

	// ControllerManager holds configuration specific to starting the controller
	// manager.
	ControllerManager *DistroContainerEnabled `json:"controllerManager,omitempty" yaml:"controllerManager,omitempty" mapstructure:"controllerManager,omitempty"`

	// Enabled specifies if the K8s distro should be enabled. Only one distro can be
	// enabled at the same time.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables to use for the main container and NOT the
	// init container.
	Env []DistroK8SEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Resources for the distro init container
	Resources DistroK8SResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scheduler holds configuration specific to starting the scheduler. Enable this
	// via controlPlane.advanced.virtualScheduler.enabled
	Scheduler *DistroContainer `json:"scheduler,omitempty" yaml:"scheduler,omitempty" mapstructure:"scheduler,omitempty"`

	// Security options can be used for the distro init container
	SecurityContext DistroK8SSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`
}

type DistroK8SEnvElem map[string]interface{}

// Resources for the distro init container
type DistroK8SResources map[string]interface{}

// Security options can be used for the distro init container
type DistroK8SSecurityContext map[string]interface{}

type EnableAutoSwitch struct {
	// Enabled defines if this option should be enabled.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type EnableSwitch struct {
	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type Etcd struct {
	// Deploy defines to use an external etcd that is deployed by the helm chart
	Deploy *EtcdDeploy `json:"deploy,omitempty" yaml:"deploy,omitempty" mapstructure:"deploy,omitempty"`

	// Embedded defines to use embedded etcd as a storage backend for the virtual
	// cluster
	Embedded *EtcdEmbedded `json:"embedded,omitempty" yaml:"embedded,omitempty" mapstructure:"embedded,omitempty"`
}

type EtcdDeploy struct {
	// Enabled defines that an external etcd should be deployed.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// HeadlessService holds options for the external etcd headless service.
	HeadlessService *EtcdDeployHeadlessService `json:"headlessService,omitempty" yaml:"headlessService,omitempty" mapstructure:"headlessService,omitempty"`

	// Service holds options for the external etcd service.
	Service *EtcdDeployService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// StatefulSet holds options for the external etcd statefulSet.
	StatefulSet *EtcdDeployStatefulSet `json:"statefulSet,omitempty" yaml:"statefulSet,omitempty" mapstructure:"statefulSet,omitempty"`
}

type EtcdDeployHeadlessService struct {
	// Annotations are extra annotations for the external etcd headless service
	Annotations EtcdDeployHeadlessServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the etcd headless service should be deployed
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

// Annotations are extra annotations for the external etcd headless service
type EtcdDeployHeadlessServiceAnnotations map[string]string

type EtcdDeployService struct {
	// Annotations are extra annotations for the external etcd service
	Annotations EtcdDeployServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the etcd service should be deployed
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

// Annotations are extra annotations for the external etcd service
type EtcdDeployServiceAnnotations map[string]string

type EtcdDeployStatefulSet struct {
	// Annotations are extra annotations for this resource.
	Annotations EtcdDeployStatefulSetAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// EnableServiceLinks for the StatefulSet pod
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Enabled defines if the statefulSet should be deployed
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Env are extra environment variables
	Env []EtcdDeployStatefulSetEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// ExtraArgs are appended to the etcd command.
	ExtraArgs []string `json:"extraArgs,omitempty" yaml:"extraArgs,omitempty" mapstructure:"extraArgs,omitempty"`

	// HighAvailability are high availability options
	HighAvailability *ExternalEtcdHighAvailability `json:"highAvailability,omitempty" yaml:"highAvailability,omitempty" mapstructure:"highAvailability,omitempty"`

	// Image is the image to use for the external etcd statefulSet
	Image *Image `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy for the external etcd image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Labels are extra labels for this resource.
	Labels EtcdDeployStatefulSetLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Persistence options for the etcd pods.
	Persistence *ExternalEtcdPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Pods defines extra metadata for the etcd pods.
	Pods *LabelsAndAnnotations `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// Resources the etcd can consume
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scheduling options for the etcd pods.
	Scheduling *ControlPlaneScheduling `json:"scheduling,omitempty" yaml:"scheduling,omitempty" mapstructure:"scheduling,omitempty"`

	// Security options for the etcd pods.
	Security *ControlPlaneSecurity `json:"security,omitempty" yaml:"security,omitempty" mapstructure:"security,omitempty"`
}

// Annotations are extra annotations for this resource.
type EtcdDeployStatefulSetAnnotations map[string]string

type EtcdDeployStatefulSetEnvElem map[string]interface{}

// Labels are extra labels for this resource.
type EtcdDeployStatefulSetLabels map[string]string

type EtcdEmbedded struct {
	// Enabled defines if the embedded etcd should be used.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// MigrateFromDeployedEtcd signals that vCluster should migrate from the deployed
	// external etcd to embedded etcd.
	MigrateFromDeployedEtcd *bool `json:"migrateFromDeployedEtcd,omitempty" yaml:"migrateFromDeployedEtcd,omitempty" mapstructure:"migrateFromDeployedEtcd,omitempty"`
}

type Experimental struct {
	// DenyProxyRequests denies certain requests in the vCluster proxy.
	DenyProxyRequests []DenyRule `json:"denyProxyRequests,omitempty" yaml:"denyProxyRequests,omitempty" mapstructure:"denyProxyRequests,omitempty"`

	// Deploy allows you to configure manifests and Helm charts to deploy within the
	// virtual cluster.
	Deploy *ExperimentalDeploy `json:"deploy,omitempty" yaml:"deploy,omitempty" mapstructure:"deploy,omitempty"`

	// GenericSync holds options to generically sync resources from virtual cluster to
	// host.
	GenericSync *ExperimentalGenericSync `json:"genericSync,omitempty" yaml:"genericSync,omitempty" mapstructure:"genericSync,omitempty"`

	// IsolatedControlPlane is a feature to run the vCluster control plane in a
	// different Kubernetes cluster than the workloads themselves.
	IsolatedControlPlane *ExperimentalIsolatedControlPlane `json:"isolatedControlPlane,omitempty" yaml:"isolatedControlPlane,omitempty" mapstructure:"isolatedControlPlane,omitempty"`

	// MultiNamespaceMode tells virtual cluster to sync to multiple namespaces instead
	// of a single one. This will map each virtual cluster namespace to a single
	// namespace in the host cluster.
	MultiNamespaceMode *ExperimentalMultiNamespaceMode `json:"multiNamespaceMode,omitempty" yaml:"multiNamespaceMode,omitempty" mapstructure:"multiNamespaceMode,omitempty"`

	// SyncSettings are advanced settings for the syncer controller.
	SyncSettings *ExperimentalSyncSettings `json:"syncSettings,omitempty" yaml:"syncSettings,omitempty" mapstructure:"syncSettings,omitempty"`

	// VirtualClusterKubeConfig allows you to override distro specifics and specify
	// where vCluster will find the required certificates and vCluster config.
	VirtualClusterKubeConfig *VirtualClusterKubeConfig `json:"virtualClusterKubeConfig,omitempty" yaml:"virtualClusterKubeConfig,omitempty" mapstructure:"virtualClusterKubeConfig,omitempty"`
}

type ExperimentalDeploy struct {
	// Helm are Helm charts that should get deployed into the virtual cluster
	Helm []ExperimentalDeployHelm `json:"helm,omitempty" yaml:"helm,omitempty" mapstructure:"helm,omitempty"`

	// Manifests are raw Kubernetes manifests that should get applied within the
	// virtual cluster.
	Manifests *string `json:"manifests,omitempty" yaml:"manifests,omitempty" mapstructure:"manifests,omitempty"`

	// ManifestsTemplate is a Kubernetes manifest template that will be rendered with
	// vCluster values before applying it within the virtual cluster.
	ManifestsTemplate *string `json:"manifestsTemplate,omitempty" yaml:"manifestsTemplate,omitempty" mapstructure:"manifestsTemplate,omitempty"`
}

type ExperimentalDeployHelm struct {
	// Bundle allows to compress the Helm chart and specify this instead of an online
	// chart
	Bundle *string `json:"bundle,omitempty" yaml:"bundle,omitempty" mapstructure:"bundle,omitempty"`

	// Chart defines what chart should get deployed.
	Chart *ExperimentalDeployHelmChart `json:"chart,omitempty" yaml:"chart,omitempty" mapstructure:"chart,omitempty"`

	// Release defines what release should get deployed.
	Release *ExperimentalDeployHelmRelease `json:"release,omitempty" yaml:"release,omitempty" mapstructure:"release,omitempty"`

	// Timeout defines the timeout for Helm
	Timeout *string `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`

	// Values defines what values should get used.
	Values *string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

type ExperimentalDeployHelmChart struct {
	// Insecure corresponds to the JSON schema field "insecure".
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Password corresponds to the JSON schema field "password".
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Repo corresponds to the JSON schema field "repo".
	Repo *string `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Username corresponds to the JSON schema field "username".
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ExperimentalDeployHelmRelease struct {
	// Name of the release
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace of the release
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

type ExperimentalGenericSync struct {
	// ClusterRole corresponds to the JSON schema field "clusterRole".
	ClusterRole *ExperimentalGenericSyncExtraRules `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Exports syncs a resource from the virtual cluster to the host
	Export []Export `json:"export,omitempty" yaml:"export,omitempty" mapstructure:"export,omitempty"`

	// Hooks are hooks that can be used to inject custom patches before syncing
	Hooks *Hooks `json:"hooks,omitempty" yaml:"hooks,omitempty" mapstructure:"hooks,omitempty"`

	// Imports syncs a resource from the host cluster to virtual cluster
	Import []Import `json:"import,omitempty" yaml:"import,omitempty" mapstructure:"import,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *ExperimentalGenericSyncExtraRules `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Version is the config version
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ExperimentalGenericSyncExtraRules struct {
	// ExtraRules corresponds to the JSON schema field "extraRules".
	ExtraRules []interface{} `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`
}

type ExperimentalIsolatedControlPlane struct {
	// Enabled specifies if the isolated control plane feature should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Headless states that Helm should deploy the vCluster in headless mode for the
	// isolated control plane.
	Headless *bool `json:"headless,omitempty" yaml:"headless,omitempty" mapstructure:"headless,omitempty"`

	// KubeConfig is the path where to find the remote workload cluster kubeconfig.
	KubeConfig *string `json:"kubeConfig,omitempty" yaml:"kubeConfig,omitempty" mapstructure:"kubeConfig,omitempty"`

	// Namespace is the namespace where to sync the workloads into.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Service is the vCluster service in the remote cluster.
	Service *string `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

type ExperimentalMultiNamespaceMode struct {
	// Enabled specifies if multi namespace mode should get enabled
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// NamespaceLabels are extra labels that will be added by vCluster to each created
	// namespace.
	NamespaceLabels ExperimentalMultiNamespaceModeNamespaceLabels `json:"namespaceLabels,omitempty" yaml:"namespaceLabels,omitempty" mapstructure:"namespaceLabels,omitempty"`
}

// NamespaceLabels are extra labels that will be added by vCluster to each created
// namespace.
type ExperimentalMultiNamespaceModeNamespaceLabels map[string]string

type ExperimentalSyncSettings struct {
	// DisableSync will not sync any resources and disable most control plane
	// functionality.
	DisableSync *bool `json:"disableSync,omitempty" yaml:"disableSync,omitempty" mapstructure:"disableSync,omitempty"`

	// HostMetricsBindAddress is the bind address for the local manager
	HostMetricsBindAddress *string `json:"hostMetricsBindAddress,omitempty" yaml:"hostMetricsBindAddress,omitempty" mapstructure:"hostMetricsBindAddress,omitempty"`

	// RewriteKubernetesService will rewrite the Kubernetes service to point to the
	// vCluster service if disableSync is enabled
	RewriteKubernetesService *bool `json:"rewriteKubernetesService,omitempty" yaml:"rewriteKubernetesService,omitempty" mapstructure:"rewriteKubernetesService,omitempty"`

	// SetOwner specifies if vCluster should set an owner reference on the synced
	// objects to the vCluster service. This allows for easy garbage collection.
	SetOwner *bool `json:"setOwner,omitempty" yaml:"setOwner,omitempty" mapstructure:"setOwner,omitempty"`

	// SyncLabels are labels that should get not rewritten when syncing from the
	// virtual cluster.
	SyncLabels []string `json:"syncLabels,omitempty" yaml:"syncLabels,omitempty" mapstructure:"syncLabels,omitempty"`

	// TargetNamespace is the namespace where the workloads should get synced to.
	TargetNamespace *string `json:"targetNamespace,omitempty" yaml:"targetNamespace,omitempty" mapstructure:"targetNamespace,omitempty"`

	// VirtualMetricsBindAddress is the bind address for the virtual manager
	VirtualMetricsBindAddress *string `json:"virtualMetricsBindAddress,omitempty" yaml:"virtualMetricsBindAddress,omitempty" mapstructure:"virtualMetricsBindAddress,omitempty"`
}

type Export struct {
	// APIVersion of the object to sync
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind of the object to sync
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// Patches are the patches to apply on the virtual cluster objects
	// when syncing them from the host cluster
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// ReplaceWhenInvalid determines if the controller should try to recreate the
	// object
	// if there is a problem applying
	ReplaceOnConflict *bool `json:"replaceOnConflict,omitempty" yaml:"replaceOnConflict,omitempty" mapstructure:"replaceOnConflict,omitempty"`

	// ReversePatches are the patches to apply to host cluster objects
	// after it has been synced to the virtual cluster
	ReversePatches []Patch `json:"reversePatches,omitempty" yaml:"reversePatches,omitempty" mapstructure:"reversePatches,omitempty"`

	// Selector is a label selector to select the synced objects in the virtual
	// cluster.
	// If empty, all objects will be synced.
	Selector *Selector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`
}

// ExportKubeConfig describes how vCluster should export the vCluster kubeconfig.
type ExportKubeConfig struct {
	// Context is the name of the context within the generated kubeconfig to use.
	Context *string `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// Declare in which host cluster secret vCluster should store the generated
	// virtual cluster kubeconfig.
	// If this is not defined, vCluster create it with `vc-NAME`. If you specify
	// another name,
	// vCluster creates the config in this other secret.
	Secret *ExportKubeConfigSecretReference `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`

	// Override the default https://localhost:8443 and specify a custom hostname for
	// the generated kubeconfig.
	Server *string `json:"server,omitempty" yaml:"server,omitempty" mapstructure:"server,omitempty"`
}

// Declare in which host cluster secret vCluster should store the generated virtual
// cluster kubeconfig.
type ExportKubeConfigSecretReference struct {
	// Name is the name of the secret where the kubeconfig should get stored.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace where vCluster should store the kubeconfig secret. If this is not
	// equal to the namespace
	// where you deployed vCluster, you need to make sure vCluster has access to this
	// other namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

type ExternalEtcdHighAvailability struct {
	// Replicas are the amount of pods to use.
	Replicas *int `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`
}

type ExternalEtcdPersistence struct {
	// AddVolumeMounts defines extra volume mounts for the container
	AddVolumeMounts []VolumeMount `json:"addVolumeMounts,omitempty" yaml:"addVolumeMounts,omitempty" mapstructure:"addVolumeMounts,omitempty"`

	// AddVolumes defines extra volumes for the pod
	AddVolumes []ExternalEtcdPersistenceAddVolumesElem `json:"addVolumes,omitempty" yaml:"addVolumes,omitempty" mapstructure:"addVolumes,omitempty"`

	// VolumeClaim can be used to configure the persistent volume claim.
	VolumeClaim *ExternalEtcdPersistenceVolumeClaim `json:"volumeClaim,omitempty" yaml:"volumeClaim,omitempty" mapstructure:"volumeClaim,omitempty"`

	// VolumeClaimTemplates defines the volumeClaimTemplates for the statefulSet
	VolumeClaimTemplates []ExternalEtcdPersistenceVolumeClaimTemplatesElem `json:"volumeClaimTemplates,omitempty" yaml:"volumeClaimTemplates,omitempty" mapstructure:"volumeClaimTemplates,omitempty"`
}

type ExternalEtcdPersistenceAddVolumesElem map[string]interface{}

type ExternalEtcdPersistenceVolumeClaim struct {
	// AccessModes are the persistent volume claim access modes.
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Enabled enables deploying a persistent volume claim.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// RetentionPolicy is the persistent volume claim retention policy.
	RetentionPolicy *string `json:"retentionPolicy,omitempty" yaml:"retentionPolicy,omitempty" mapstructure:"retentionPolicy,omitempty"`

	// Size is the persistent volume claim storage size.
	Size *string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// StorageClass is the persistent volume claim storage class.
	StorageClass *string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

type ExternalEtcdPersistenceVolumeClaimTemplatesElem map[string]interface{}

type Hook struct {
	// APIVersion of the object to sync
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind of the object to sync
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Patches are the patches to apply on the object to be synced
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// Verbs are the verbs that the hook should mutate
	Verbs []string `json:"verbs,omitempty" yaml:"verbs,omitempty" mapstructure:"verbs,omitempty"`
}

type Hooks struct {
	// HostToVirtual is a hook that is executed before syncing from the host to the
	// virtual cluster
	HostToVirtual []Hook `json:"hostToVirtual,omitempty" yaml:"hostToVirtual,omitempty" mapstructure:"hostToVirtual,omitempty"`

	// VirtualToHost is a hook that is executed before syncing from the virtual to the
	// host cluster
	VirtualToHost []Hook `json:"virtualToHost,omitempty" yaml:"virtualToHost,omitempty" mapstructure:"virtualToHost,omitempty"`
}

type HostPathMapper struct {
	// Central specifies if the central host path mapper will be used
	Central *bool `json:"central,omitempty" yaml:"central,omitempty" mapstructure:"central,omitempty"`

	// Enabled specifies if the host path mapper will be used
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type IPBlock struct {
	// cidr is a string representing the IPBlock
	// Valid examples are "192.168.1.0/24" or "2001:db8::/64"
	Cidr *string `json:"cidr,omitempty" yaml:"cidr,omitempty" mapstructure:"cidr,omitempty"`

	// except is a slice of CIDRs that should not be included within an IPBlock
	// Valid examples are "192.168.1.0/24" or "2001:db8::/64"
	// Except values will be rejected if they are outside the cidr range
	// +optional
	Except []string `json:"except,omitempty" yaml:"except,omitempty" mapstructure:"except,omitempty"`
}

type Image struct {
	// Registry is the registry of the container image, e.g. my-registry.com or
	// ghcr.io. This setting can be globally
	// overridden via the controlPlane.advanced.defaultImageRegistry option. Empty
	// means docker hub.
	Registry *string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Repository is the repository of the container image, e.g. my-repo/my-image
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`

	// Tag is the tag of the container image, e.g. latest
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type ImagePullSecretName struct {
	// Name of the image pull secret to use.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type Import struct {
	// APIVersion of the object to sync
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind of the object to sync
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// Patches are the patches to apply on the virtual cluster objects
	// when syncing them from the host cluster
	Patches []Patch `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// ReplaceWhenInvalid determines if the controller should try to recreate the
	// object
	// if there is a problem applying
	ReplaceOnConflict *bool `json:"replaceOnConflict,omitempty" yaml:"replaceOnConflict,omitempty" mapstructure:"replaceOnConflict,omitempty"`

	// ReversePatches are the patches to apply to host cluster objects
	// after it has been synced to the virtual cluster
	ReversePatches []Patch `json:"reversePatches,omitempty" yaml:"reversePatches,omitempty" mapstructure:"reversePatches,omitempty"`
}

type LabelsAndAnnotations struct {
	// Annotations are extra annotations for this resource.
	Annotations LabelsAndAnnotationsAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels are extra labels for this resource.
	Labels LabelsAndAnnotationsLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are extra annotations for this resource.
type LabelsAndAnnotationsAnnotations map[string]string

// Labels are extra labels for this resource.
type LabelsAndAnnotationsLabels map[string]string

type LimitRange struct {
	// Annotations are extra annotations for this resource.
	Annotations LimitRangeAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Default are the default limits for the limit range
	Default LimitRangeDefault `json:"default,omitempty" yaml:"default,omitempty" mapstructure:"default,omitempty"`

	// DefaultRequest are the default request options for the limit range
	DefaultRequest LimitRangeDefaultRequest `json:"defaultRequest,omitempty" yaml:"defaultRequest,omitempty" mapstructure:"defaultRequest,omitempty"`

	// Enabled defines if the limit range should be deployed by vCluster.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Labels are extra labels for this resource.
	Labels LimitRangeLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are extra annotations for this resource.
type LimitRangeAnnotations map[string]string

// Default are the default limits for the limit range
type LimitRangeDefault map[string]interface{}

// DefaultRequest are the default request options for the limit range
type LimitRangeDefaultRequest map[string]interface{}

// Labels are extra labels for this resource.
type LimitRangeLabels map[string]string

type MetricsProxy struct {
	// Nodes defines if metrics-server nodes api should get proxied from host to
	// virtual cluster.
	Nodes *bool `json:"nodes,omitempty" yaml:"nodes,omitempty" mapstructure:"nodes,omitempty"`

	// Pods defines if metrics-server pods api should get proxied from host to virtual
	// cluster.
	Pods *bool `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`
}

type MutatingWebhook struct {
	// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
	// versions the Webhook expects.
	AdmissionReviewVersions []string `json:"admissionReviewVersions,omitempty" yaml:"admissionReviewVersions,omitempty" mapstructure:"admissionReviewVersions,omitempty"`

	// ClientConfig defines how to communicate with the hook.
	ClientConfig *ValidatingWebhookClientConfig `json:"clientConfig,omitempty" yaml:"clientConfig,omitempty" mapstructure:"clientConfig,omitempty"`

	// FailurePolicy defines how unrecognized errors from the admission endpoint are
	// handled -
	// allowed values are Ignore or Fail. Defaults to Fail.
	FailurePolicy *string `json:"failurePolicy,omitempty" yaml:"failurePolicy,omitempty" mapstructure:"failurePolicy,omitempty"`

	// MatchConditions is a list of conditions that must be met for a request to be
	// sent to this
	// webhook. Match conditions filter requests that have already been matched by the
	// rules,
	// namespaceSelector, and objectSelector. An empty list of matchConditions matches
	// all requests.
	// There are a maximum of 64 match conditions allowed.
	MatchConditions []interface{} `json:"matchConditions,omitempty" yaml:"matchConditions,omitempty" mapstructure:"matchConditions,omitempty"`

	// matchPolicy defines how the "rules" list is used to match incoming requests.
	// Allowed values are "Exact" or "Equivalent".
	MatchPolicy *string `json:"matchPolicy,omitempty" yaml:"matchPolicy,omitempty" mapstructure:"matchPolicy,omitempty"`

	// The name of the admission webhook.
	// Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
	// "imagepolicy" is the name of the webhook, and kubernetes.io is the name
	// of the organization.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// NamespaceSelector decides whether to run the webhook on an object based
	// on whether the namespace for that object matches the selector. If the
	// object itself is a namespace, the matching is performed on
	// object.metadata.labels. If the object is another cluster scoped resource,
	// it never skips the webhook.
	NamespaceSelector interface{} `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// ObjectSelector decides whether to run the webhook based on if the
	// object has matching labels. objectSelector is evaluated against both
	// the oldObject and newObject that would be sent to the webhook, and
	// is considered to match if either object matches the selector.
	ObjectSelector interface{} `json:"objectSelector,omitempty" yaml:"objectSelector,omitempty" mapstructure:"objectSelector,omitempty"`

	// reinvocationPolicy indicates whether this webhook should be called multiple
	// times as part of a single admission evaluation.
	// Allowed values are "Never" and "IfNeeded".
	ReinvocationPolicy *string `json:"reinvocationPolicy,omitempty" yaml:"reinvocationPolicy,omitempty" mapstructure:"reinvocationPolicy,omitempty"`

	// Rules describes what operations on what resources/subresources the webhook
	// cares about.
	// The webhook cares about an operation if it matches _any_ Rule.
	Rules []interface{} `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// SideEffects states whether this webhook has side effects.
	SideEffects *string `json:"sideEffects,omitempty" yaml:"sideEffects,omitempty" mapstructure:"sideEffects,omitempty"`

	// TimeoutSeconds specifies the timeout for this webhook.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type MutatingWebhookConfiguration struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Standard object metadata; More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
	Metadata *ObjectMeta `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Webhooks is a list of webhooks and the affected resources and operations.
	Webhooks []MutatingWebhook `json:"webhooks,omitempty" yaml:"webhooks,omitempty" mapstructure:"webhooks,omitempty"`
}

type NetworkPolicy struct {
	// Annotations are extra annotations for this resource.
	Annotations NetworkPolicyAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the network policy should be deployed by vCluster.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// FallbackDns corresponds to the JSON schema field "fallbackDns".
	FallbackDns *string `json:"fallbackDns,omitempty" yaml:"fallbackDns,omitempty" mapstructure:"fallbackDns,omitempty"`

	// Labels are extra labels for this resource.
	Labels NetworkPolicyLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// OutgoingConnections corresponds to the JSON schema field "outgoingConnections".
	OutgoingConnections *OutgoingConnections `json:"outgoingConnections,omitempty" yaml:"outgoingConnections,omitempty" mapstructure:"outgoingConnections,omitempty"`
}

// Annotations are extra annotations for this resource.
type NetworkPolicyAnnotations map[string]string

// Labels are extra labels for this resource.
type NetworkPolicyLabels map[string]string

type NetworkProxyKubelets struct {
	// ByHostname will add a special vCluster hostname to the nodes where the node can
	// be reached at. This doesn't work
	// for all applications, e.g. Prometheus requires a node IP.
	ByHostname *bool `json:"byHostname,omitempty" yaml:"byHostname,omitempty" mapstructure:"byHostname,omitempty"`

	// ByIP will create a separate service in the host cluster for every node that
	// will point to virtual cluster and will be used to
	// route traffic.
	ByIP *bool `json:"byIP,omitempty" yaml:"byIP,omitempty" mapstructure:"byIP,omitempty"`
}

type Networking struct {
	// Advanced holds advanced network options.
	Advanced *NetworkingAdvanced `json:"advanced,omitempty" yaml:"advanced,omitempty" mapstructure:"advanced,omitempty"`

	// ReplicateServices allows replicating services from the host within the virtual
	// cluster or the other way around.
	ReplicateServices *ReplicateServices `json:"replicateServices,omitempty" yaml:"replicateServices,omitempty" mapstructure:"replicateServices,omitempty"`

	// ResolveDNS allows to define extra DNS rules. This only works if embedded
	// coredns is configured.
	ResolveDNS []ResolveDNS `json:"resolveDNS,omitempty" yaml:"resolveDNS,omitempty" mapstructure:"resolveDNS,omitempty"`
}

type NetworkingAdvanced struct {
	// ClusterDomain is the Kubernetes cluster domain to use within the virtual
	// cluster.
	ClusterDomain *string `json:"clusterDomain,omitempty" yaml:"clusterDomain,omitempty" mapstructure:"clusterDomain,omitempty"`

	// FallbackHostCluster allows to fallback dns to the host cluster. This is useful
	// if you want to reach host services without
	// any other modification. You will need to provide a namespace for the service,
	// e.g. my-other-service.my-other-namespace
	FallbackHostCluster *bool `json:"fallbackHostCluster,omitempty" yaml:"fallbackHostCluster,omitempty" mapstructure:"fallbackHostCluster,omitempty"`

	// ProxyKubelets allows rewriting certain metrics and stats from the Kubelet to
	// "fake" this for applications such as
	// prometheus or other node exporters.
	ProxyKubelets *NetworkProxyKubelets `json:"proxyKubelets,omitempty" yaml:"proxyKubelets,omitempty" mapstructure:"proxyKubelets,omitempty"`
}

type ObjectMeta struct {
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata.
	Annotations ObjectMetaAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	Labels ObjectMetaLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name must be unique within a namespace. Is required when creating resources,
	// although
	// some resources may allow a client to request the generation of an appropriate
	// name
	// automatically. Name is primarily intended for creation idempotence and
	// configuration
	// definition.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Annotations is an unstructured key value map stored with a resource that may be
// set by external tools to store and retrieve arbitrary metadata.
type ObjectMetaAnnotations map[string]string

// Map of string keys and values that can be used to organize and categorize
// (scope and select) objects. May match selectors of replication controllers
// and services.
type ObjectMetaLabels map[string]string

type Observability struct {
	// Metrics allows to proxy metrics server apis from host to virtual cluster.
	Metrics *ObservabilityMetrics `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

type ObservabilityMetrics struct {
	// Proxy holds the configuration what metrics-server apis should get proxied.
	Proxy *MetricsProxy `json:"proxy,omitempty" yaml:"proxy,omitempty" mapstructure:"proxy,omitempty"`
}

type OutgoingConnections struct {
	// IPBlock describes a particular CIDR (Ex. "192.168.1.0/24","2001:db8::/64") that
	// is allowed
	// to the pods matched by a NetworkPolicySpec's podSelector. The except entry
	// describes CIDRs
	// that should not be included within this rule.
	IpBlock *IPBlock `json:"ipBlock,omitempty" yaml:"ipBlock,omitempty" mapstructure:"ipBlock,omitempty"`
}

type Patch struct {
	// Conditions are conditions that must be true for
	// the patch to get executed
	Conditions []PatchCondition `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// FromPath is the path from the other object
	FromPath *string `json:"fromPath,omitempty" yaml:"fromPath,omitempty" mapstructure:"fromPath,omitempty"`

	// Ignore determines if the path should be ignored if handled as a reverse patch
	Ignore *bool `json:"ignore,omitempty" yaml:"ignore,omitempty" mapstructure:"ignore,omitempty"`

	// NamePath is the path to the name of a child resource within Path
	NamePath *string `json:"namePath,omitempty" yaml:"namePath,omitempty" mapstructure:"namePath,omitempty"`

	// NamespacePath is path to the namespace of a child resource within Path
	NamespacePath *string `json:"namespacePath,omitempty" yaml:"namespacePath,omitempty" mapstructure:"namespacePath,omitempty"`

	// Operation is the type of the patch
	Op *string `json:"op,omitempty" yaml:"op,omitempty" mapstructure:"op,omitempty"`

	// Path is the path of the patch
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Regex - is regular expresion used to identify the Name,
	// and optionally Namespace, parts of the field value that
	// will be replaced with the rewritten Name and/or Namespace
	Regex *string `json:"regex,omitempty" yaml:"regex,omitempty" mapstructure:"regex,omitempty"`

	// Sync defines if a specialized syncer should be initialized using values
	// from the rewriteName operation as Secret/Configmap names to be synced
	Sync *PatchSync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`

	// Value is the new value to be set to the path
	Value interface{} `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type PatchCondition struct {
	// Empty means that the path value should be empty or unset
	Empty *bool `json:"empty,omitempty" yaml:"empty,omitempty" mapstructure:"empty,omitempty"`

	// Equal is the value the path should be equal to
	Equal interface{} `json:"equal,omitempty" yaml:"equal,omitempty" mapstructure:"equal,omitempty"`

	// NotEqual is the value the path should not be equal to
	NotEqual interface{} `json:"notEqual,omitempty" yaml:"notEqual,omitempty" mapstructure:"notEqual,omitempty"`

	// Path is the path within the object to select
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// SubPath is the path below the selected object to select
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`
}

type PatchSync struct {
	// Configmap corresponds to the JSON schema field "configmap".
	Configmap *bool `json:"configmap,omitempty" yaml:"configmap,omitempty" mapstructure:"configmap,omitempty"`

	// Secret corresponds to the JSON schema field "secret".
	Secret *bool `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

type Platform struct {
	// API defines how vCluster can contact the platform api.
	Api *PlatformAPI `json:"api,omitempty" yaml:"api,omitempty" mapstructure:"api,omitempty"`

	// Name is the name of the vCluster instance in the vCluster platform
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Owner is the desired owner of the vCluster instance within the vCluster
	// platform. If empty will take the current user.
	Owner *PlatformOwner `json:"owner,omitempty" yaml:"owner,omitempty" mapstructure:"owner,omitempty"`

	// Project is the project within the platform where the vCluster instance should
	// connect.
	Project *string `json:"project,omitempty" yaml:"project,omitempty" mapstructure:"project,omitempty"`
}

type PlatformAPI struct {
	// AccessKey specifies the access key as a regular text value.
	AccessKey *string `json:"accessKey,omitempty" yaml:"accessKey,omitempty" mapstructure:"accessKey,omitempty"`

	// Host specifies the platform host to use.
	Host *string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Insecure specifies if the host uses a self-signed certificate.
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// SecretRef defines where to find the platform access key and host. By default,
	// vCluster will search in the following locations in this precedence:
	// * platform.api.accessKey
	// * environment variable called LICENSE
	// * secret specified under platform.api.secretRef.name
	// * secret called "vcluster-platform-api-key" in the vCluster namespace
	SecretRef *PlatformAccessKeySecretReference `json:"secretRef,omitempty" yaml:"secretRef,omitempty" mapstructure:"secretRef,omitempty"`
}

// PlatformAccessKeySecretReference defines where to find the platform access key.
type PlatformAccessKeySecretReference struct {
	// Name is the name of the secret where the platform access key is stored. This
	// defaults to vcluster-platform-api-key if undefined.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace defines the namespace where the access key secret should be retrieved
	// from. If this is not equal to the namespace
	// where the vCluster instance is deployed, you need to make sure vCluster has
	// access to this other namespace.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

type PlatformOwner struct {
	// Team is the team id within the platform. This is mutually exclusive with user.
	Team *string `json:"team,omitempty" yaml:"team,omitempty" mapstructure:"team,omitempty"`

	// User is the user id within the platform. This is mutually exclusive with team.
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

type Plugin struct {
	// Args are the arguments that should be used for the init container
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command is the command that should be used for the init container
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Config is the plugin config to use. This can be arbitrary config used for the
	// plugin.
	Config PluginConfig `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Env corresponds to the JSON schema field "env".
	Env []interface{} `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// EnvFrom corresponds to the JSON schema field "envFrom".
	EnvFrom []interface{} `json:"envFrom,omitempty" yaml:"envFrom,omitempty" mapstructure:"envFrom,omitempty"`

	// Image is the container image that should be used for the plugin
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy to use for the container image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Lifecycle corresponds to the JSON schema field "lifecycle".
	Lifecycle PluginLifecycle `json:"lifecycle,omitempty" yaml:"lifecycle,omitempty" mapstructure:"lifecycle,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe PluginLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// Name is the name of the init-container and NOT the plugin name
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// RBAC holds additional rbac configuration for the plugin
	Rbac *PluginsRBAC `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe PluginReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Resources are the container resources used for the init container
	Resources PluginResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// SecurityContext is the container security context used for the init container
	SecurityContext PluginSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe PluginStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Version is the plugin version, this is only needed for legacy plugins.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`

	// VolumeMounts are extra volume mounts for the init container
	VolumeMounts []interface{} `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`

	// WorkingDir corresponds to the JSON schema field "workingDir".
	WorkingDir *string `json:"workingDir,omitempty" yaml:"workingDir,omitempty" mapstructure:"workingDir,omitempty"`
}

// Config is the plugin config to use. This can be arbitrary config used for the
// plugin.
type PluginConfig map[string]interface{}

type PluginLifecycle map[string]interface{}

type PluginLivenessProbe map[string]interface{}

type PluginReadinessProbe map[string]interface{}

// Resources are the container resources used for the init container
type PluginResources map[string]interface{}

// SecurityContext is the container security context used for the init container
type PluginSecurityContext map[string]interface{}

type PluginStartupProbe map[string]interface{}

type Plugins struct {
	// Args are the arguments that should be used for the init container
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command is the command that should be used for the init container
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Config is the plugin config to use. This can be arbitrary config used for the
	// plugin.
	Config PluginsConfig `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Image is the container image that should be used for the plugin
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// ImagePullPolicy is the pull policy to use for the container image
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" yaml:"imagePullPolicy,omitempty" mapstructure:"imagePullPolicy,omitempty"`

	// Name is the name of the init-container and NOT the plugin name
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// RBAC holds additional rbac configuration for the plugin
	Rbac *PluginsRBAC `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// Resources are the container resources used for the init container
	Resources PluginsResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// SecurityContext is the container security context used for the init container
	SecurityContext PluginsSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// VolumeMounts are extra volume mounts for the init container
	VolumeMounts []interface{} `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// Config is the plugin config to use. This can be arbitrary config used for the
// plugin.
type PluginsConfig map[string]interface{}

type PluginsExtraRules struct {
	// ExtraRules are extra rbac permissions roles that will be added to role or
	// cluster role
	ExtraRules []RBACPolicyRule `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`
}

type PluginsRBAC struct {
	// ClusterRole holds extra virtual cluster cluster role permissions required for
	// the plugin
	ClusterRole *PluginsExtraRules `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Role holds extra virtual cluster role permissions for the plugin
	Role *PluginsExtraRules `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`
}

// Resources are the container resources used for the init container
type PluginsResources map[string]interface{}

// SecurityContext is the container security context used for the init container
type PluginsSecurityContext map[string]interface{}

type Policies struct {
	// CentralAdmission defines what validating or mutating webhooks should be
	// enforced within the virtual cluster.
	CentralAdmission *CentralAdmission `json:"centralAdmission,omitempty" yaml:"centralAdmission,omitempty" mapstructure:"centralAdmission,omitempty"`

	// LimitRange specifies limit range options.
	LimitRange *LimitRange `json:"limitRange,omitempty" yaml:"limitRange,omitempty" mapstructure:"limitRange,omitempty"`

	// NetworkPolicy specifies network policy options.
	NetworkPolicy *NetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty" mapstructure:"networkPolicy,omitempty"`

	// PodSecurityStandard that can be enforced can be one of: empty (""), baseline,
	// restricted or privileged
	PodSecurityStandard *string `json:"podSecurityStandard,omitempty" yaml:"podSecurityStandard,omitempty" mapstructure:"podSecurityStandard,omitempty"`

	// ResourceQuota specifies resource quota options.
	ResourceQuota *ResourceQuota `json:"resourceQuota,omitempty" yaml:"resourceQuota,omitempty" mapstructure:"resourceQuota,omitempty"`
}

type RBAC struct {
	// ClusterRole holds virtual cluster cluster role configuration
	ClusterRole *RBACClusterRole `json:"clusterRole,omitempty" yaml:"clusterRole,omitempty" mapstructure:"clusterRole,omitempty"`

	// Role holds virtual cluster role configuration
	Role *RBACRole `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`
}

type RBACClusterRole struct {
	// Enabled defines if the cluster role should be enabled or disabled. If auto,
	// vCluster automatically determines whether the virtual cluster requires a
	// cluster role.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExtraRules will add rules to the cluster role.
	ExtraRules []RBACClusterRoleExtraRulesElem `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`

	// OverwriteRules will overwrite the cluster role rules completely.
	OverwriteRules []RBACClusterRoleOverwriteRulesElem `json:"overwriteRules,omitempty" yaml:"overwriteRules,omitempty" mapstructure:"overwriteRules,omitempty"`
}

type RBACClusterRoleExtraRulesElem map[string]interface{}

type RBACClusterRoleOverwriteRulesElem map[string]interface{}

type RBACPolicyRule struct {
	// APIGroups is the name of the APIGroup that contains the resources.  If multiple
	// API groups are specified, any action requested against one of
	// the enumerated resources in any API group will be allowed. "" represents the
	// core API group and "*" represents all API groups.
	ApiGroups []string `json:"apiGroups,omitempty" yaml:"apiGroups,omitempty" mapstructure:"apiGroups,omitempty"`

	// NonResourceURLs is a set of partial urls that a user should have access to.  *s
	// are allowed, but only as the full, final step in the path
	// Since non-resource URLs are not namespaced, this field is only applicable for
	// ClusterRoles referenced from a ClusterRoleBinding.
	// Rules can either apply to API resources (such as "pods" or "secrets") or
	// non-resource URL paths (such as "/api"),  but not both.
	NonResourceURLs []string `json:"nonResourceURLs,omitempty" yaml:"nonResourceURLs,omitempty" mapstructure:"nonResourceURLs,omitempty"`

	// ResourceNames is an optional white list of names that the rule applies to.  An
	// empty set means that everything is allowed.
	ResourceNames []string `json:"resourceNames,omitempty" yaml:"resourceNames,omitempty" mapstructure:"resourceNames,omitempty"`

	// Resources is a list of resources this rule applies to. '*' represents all
	// resources.
	Resources []string `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this
	// rule. '*' represents all verbs.
	Verbs []string `json:"verbs,omitempty" yaml:"verbs,omitempty" mapstructure:"verbs,omitempty"`
}

type RBACRole struct {
	// Enabled defines if the role should be enabled or disabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// ExtraRules will add rules to the role.
	ExtraRules []RBACRoleExtraRulesElem `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`

	// OverwriteRules will overwrite the role rules completely.
	OverwriteRules []RBACRoleOverwriteRulesElem `json:"overwriteRules,omitempty" yaml:"overwriteRules,omitempty" mapstructure:"overwriteRules,omitempty"`
}

type RBACRoleExtraRulesElem map[string]interface{}

type RBACRoleOverwriteRulesElem map[string]interface{}

type ReplicateServices struct {
	// FromHost defines the services that should get synced from the host to the
	// virtual cluster.
	FromHost []ServiceMapping `json:"fromHost,omitempty" yaml:"fromHost,omitempty" mapstructure:"fromHost,omitempty"`

	// ToHost defines the services that should get synced from virtual cluster to the
	// host cluster. If services are
	// synced to a different namespace than the virtual cluster is in, additional
	// permissions for the other namespace
	// are required.
	ToHost []ServiceMapping `json:"toHost,omitempty" yaml:"toHost,omitempty" mapstructure:"toHost,omitempty"`
}

type ResolveDNS struct {
	// Hostname is the hostname within the vCluster that should be resolved from.
	Hostname *string `json:"hostname,omitempty" yaml:"hostname,omitempty" mapstructure:"hostname,omitempty"`

	// Namespace is the virtual cluster namespace that should be resolved from.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Service is the virtual cluster service that should be resolved from.
	Service *string `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// Target is the DNS target that should get mapped to
	Target *ResolveDNSTarget `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`
}

type ResolveDNSTarget struct {
	// HostNamespace to target
	HostNamespace *string `json:"hostNamespace,omitempty" yaml:"hostNamespace,omitempty" mapstructure:"hostNamespace,omitempty"`

	// HostService to target, format is hostNamespace/hostService
	HostService *string `json:"hostService,omitempty" yaml:"hostService,omitempty" mapstructure:"hostService,omitempty"`

	// Hostname to use as a DNS target
	Hostname *string `json:"hostname,omitempty" yaml:"hostname,omitempty" mapstructure:"hostname,omitempty"`

	// IP to use as a DNS target
	Ip *string `json:"ip,omitempty" yaml:"ip,omitempty" mapstructure:"ip,omitempty"`

	// VClusterService format is
	// hostNamespace/vClusterName/vClusterNamespace/vClusterService
	VClusterService *string `json:"vClusterService,omitempty" yaml:"vClusterService,omitempty" mapstructure:"vClusterService,omitempty"`
}

type ResourceQuota struct {
	// Annotations are extra annotations for this resource.
	Annotations ResourceQuotaAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled defines if the resource quota should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Labels are extra labels for this resource.
	Labels ResourceQuotaLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Quota are the quota options
	Quota ResourceQuotaQuota `json:"quota,omitempty" yaml:"quota,omitempty" mapstructure:"quota,omitempty"`

	// ScopeSelector is the resource quota scope selector
	ScopeSelector ResourceQuotaScopeSelector `json:"scopeSelector,omitempty" yaml:"scopeSelector,omitempty" mapstructure:"scopeSelector,omitempty"`

	// Scopes are the resource quota scopes
	Scopes []string `json:"scopes,omitempty" yaml:"scopes,omitempty" mapstructure:"scopes,omitempty"`
}

// Annotations are extra annotations for this resource.
type ResourceQuotaAnnotations map[string]string

// Labels are extra labels for this resource.
type ResourceQuotaLabels map[string]string

// Quota are the quota options
type ResourceQuotaQuota map[string]interface{}

// ScopeSelector is the resource quota scope selector
type ResourceQuotaScopeSelector map[string]interface{}

type Resources struct {
	// Limits are resource limits for the container
	Limits ResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests are minimal resources that will be consumed by the container
	Requests ResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// Limits are resource limits for the container
type ResourcesLimits map[string]interface{}

// Requests are minimal resources that will be consumed by the container
type ResourcesRequests map[string]interface{}

type RuleWithVerbs struct {
	// APIGroups is the API groups the resources belong to. '*' is all groups.
	ApiGroups []string `json:"apiGroups,omitempty" yaml:"apiGroups,omitempty" mapstructure:"apiGroups,omitempty"`

	// APIVersions is the API versions the resources belong to. '*' is all versions.
	ApiVersions []string `json:"apiVersions,omitempty" yaml:"apiVersions,omitempty" mapstructure:"apiVersions,omitempty"`

	// Verb is the kube verb associated with the request for API requests, not the
	// http verb. This includes things like list and watch.
	// For non-resource requests, this is the lowercase http verb.
	// If '*' is present, the length of the slice must be one.
	Operations []string `json:"operations,omitempty" yaml:"operations,omitempty" mapstructure:"operations,omitempty"`

	// Resources is a list of resources this rule applies to.
	Resources []string `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Scope specifies the scope of this rule.
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`
}

// Config is the vCluster config.
type SchemaV0195Json struct {
	// Configure vCluster's control plane components and deployment.
	ControlPlane *ControlPlane `json:"controlPlane,omitempty" yaml:"controlPlane,omitempty" mapstructure:"controlPlane,omitempty"`

	// Experimental features for vCluster. Configuration here might change, so be
	// careful with this.
	Experimental *Experimental `json:"experimental,omitempty" yaml:"experimental,omitempty" mapstructure:"experimental,omitempty"`

	// ExportKubeConfig describes how vCluster should export the vCluster kubeConfig
	// file.
	ExportKubeConfig *ExportKubeConfig `json:"exportKubeConfig,omitempty" yaml:"exportKubeConfig,omitempty" mapstructure:"exportKubeConfig,omitempty"`

	// Global values shared across all (sub)charts
	Global interface{} `json:"global,omitempty" yaml:"global,omitempty" mapstructure:"global,omitempty"`

	// Networking options related to the virtual cluster.
	Networking *Networking `json:"networking,omitempty" yaml:"networking,omitempty" mapstructure:"networking,omitempty"`

	// Observability holds options to proxy metrics from the host cluster into the
	// virtual cluster.
	Observability *Observability `json:"observability,omitempty" yaml:"observability,omitempty" mapstructure:"observability,omitempty"`

	// Platform holds options for connecting to vCluster Platform.
	Platform *Platform `json:"platform,omitempty" yaml:"platform,omitempty" mapstructure:"platform,omitempty"`

	// Plugin specifies which vCluster plugins to enable. Use "plugins" instead. Do
	// not use this option anymore.
	Plugin interface{} `json:"plugin,omitempty" yaml:"plugin,omitempty" mapstructure:"plugin,omitempty"`

	// Define which vCluster plugins to load.
	Plugins interface{} `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`

	// Policies to enforce for the virtual cluster deployment as well as within the
	// virtual cluster.
	Policies *Policies `json:"policies,omitempty" yaml:"policies,omitempty" mapstructure:"policies,omitempty"`

	// Specifies whether to use vCluster Pro. This is automatically inferred in newer
	// versions. Do not use that option anymore.
	Pro *bool `json:"pro,omitempty" yaml:"pro,omitempty" mapstructure:"pro,omitempty"`

	// RBAC options for the virtual cluster.
	Rbac *RBAC `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// ServiceCIDR holds the service cidr for the virtual cluster. Do not use this
	// option anymore.
	ServiceCIDR *string `json:"serviceCIDR,omitempty" yaml:"serviceCIDR,omitempty" mapstructure:"serviceCIDR,omitempty"`

	// Sync describes how to sync resources from the virtual cluster to host cluster
	// and back.
	Sync *Sync `json:"sync,omitempty" yaml:"sync,omitempty" mapstructure:"sync,omitempty"`

	// Configuration related to telemetry gathered about vCluster usage.
	Telemetry *Telemetry `json:"telemetry,omitempty" yaml:"telemetry,omitempty" mapstructure:"telemetry,omitempty"`
}

type Selector struct {
	// LabelSelector are the labels to select the object from
	LabelSelector SelectorLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`
}

// LabelSelector are the labels to select the object from
type SelectorLabelSelector map[string]string

type ServiceMapping struct {
	// From is the service that should get synced. Can be either in the form name or
	// namespace/name.
	From *string `json:"from,omitempty" yaml:"from,omitempty" mapstructure:"from,omitempty"`

	// To is the target service that it should get synced to. Can be either in the
	// form name or namespace/name.
	To *string `json:"to,omitempty" yaml:"to,omitempty" mapstructure:"to,omitempty"`
}

type ServiceMonitor struct {
	// Annotations are the extra annotations to add to the service monitor.
	Annotations ServiceMonitorAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enabled configures if Helm should create the service monitor.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Labels are the extra labels to add to the service monitor.
	Labels ServiceMonitorLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations are the extra annotations to add to the service monitor.
type ServiceMonitorAnnotations map[string]string

// Labels are the extra labels to add to the service monitor.
type ServiceMonitorLabels map[string]string

type StatefulSetImage struct {
	// Configure the registry of the container image, e.g. my-registry.com or ghcr.io
	// It defaults to ghcr.io and can be overriding either by using this field or
	// controlPlane.advanced.defaultImageRegistry
	Registry *string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Configure the repository of the container image, e.g. my-repo/my-image.
	// It defaults to the vCluster pro repository that includes the optional pro
	// modules that are turned off by default.
	// If you still want to use the pure OSS build, use 'loft-sh/vcluster-oss'
	// instead.
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`

	// Tag is the tag of the container image, e.g. latest
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type Sync struct {
	// Configure what resources vCluster should sync from the host cluster to the
	// virtual cluster.
	FromHost *SyncFromHost `json:"fromHost,omitempty" yaml:"fromHost,omitempty" mapstructure:"fromHost,omitempty"`

	// Configure resources to sync from the virtual cluster to the host cluster.
	ToHost *SyncToHost `json:"toHost,omitempty" yaml:"toHost,omitempty" mapstructure:"toHost,omitempty"`
}

type SyncAllResource struct {
	// All defines if all resources of that type should get synced or only the
	// necessary ones that are needed.
	All *bool `json:"all,omitempty" yaml:"all,omitempty" mapstructure:"all,omitempty"`

	// Enabled defines if this option should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type SyncFromHost struct {
	// CSIDrivers defines if csi drivers should get synced from the host cluster to
	// the virtual cluster, but not back. If auto, is automatically enabled when the
	// virtual scheduler is enabled.
	CsiDrivers *EnableAutoSwitch `json:"csiDrivers,omitempty" yaml:"csiDrivers,omitempty" mapstructure:"csiDrivers,omitempty"`

	// CSINodes defines if csi nodes should get synced from the host cluster to the
	// virtual cluster, but not back. If auto, is automatically enabled when the
	// virtual scheduler is enabled.
	CsiNodes *EnableAutoSwitch `json:"csiNodes,omitempty" yaml:"csiNodes,omitempty" mapstructure:"csiNodes,omitempty"`

	// CSIStorageCapacities defines if csi storage capacities should get synced from
	// the host cluster to the virtual cluster, but not back. If auto, is
	// automatically enabled when the virtual scheduler is enabled.
	CsiStorageCapacities *EnableAutoSwitch `json:"csiStorageCapacities,omitempty" yaml:"csiStorageCapacities,omitempty" mapstructure:"csiStorageCapacities,omitempty"`

	// Events defines if events should get synced from the host cluster to the virtual
	// cluster, but not back.
	Events *EnableSwitch `json:"events,omitempty" yaml:"events,omitempty" mapstructure:"events,omitempty"`

	// IngressClasses defines if ingress classes should get synced from the host
	// cluster to the virtual cluster, but not back.
	IngressClasses *EnableSwitch `json:"ingressClasses,omitempty" yaml:"ingressClasses,omitempty" mapstructure:"ingressClasses,omitempty"`

	// Nodes defines if nodes should get synced from the host cluster to the virtual
	// cluster, but not back.
	Nodes *SyncNodes `json:"nodes,omitempty" yaml:"nodes,omitempty" mapstructure:"nodes,omitempty"`

	// StorageClasses defines if storage classes should get synced from the host
	// cluster to the virtual cluster, but not back. If auto, is automatically enabled
	// when the virtual scheduler is enabled.
	StorageClasses *EnableAutoSwitch `json:"storageClasses,omitempty" yaml:"storageClasses,omitempty" mapstructure:"storageClasses,omitempty"`
}

type SyncNodeSelector struct {
	// All specifies if all nodes should get synced by vCluster from the host to the
	// virtual cluster or only the ones where pods are assigned to.
	All *bool `json:"all,omitempty" yaml:"all,omitempty" mapstructure:"all,omitempty"`

	// Labels are the node labels used to sync nodes from host cluster to virtual
	// cluster. This will also set the node selector when syncing a pod from virtual
	// cluster to host cluster to the same value.
	Labels SyncNodeSelectorLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Labels are the node labels used to sync nodes from host cluster to virtual
// cluster. This will also set the node selector when syncing a pod from virtual
// cluster to host cluster to the same value.
type SyncNodeSelectorLabels map[string]string

type SyncNodes struct {
	// ClearImageStatus will erase the image status when syncing a node. This allows
	// to hide images that are pulled by the node.
	ClearImageStatus *bool `json:"clearImageStatus,omitempty" yaml:"clearImageStatus,omitempty" mapstructure:"clearImageStatus,omitempty"`

	// Enabled specifies if syncing real nodes should be enabled. If this is disabled,
	// vCluster will create fake nodes instead.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Selector can be used to define more granular what nodes should get synced from
	// the host cluster to the virtual cluster.
	Selector *SyncNodeSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// SyncBackChanges enables syncing labels and taints from the virtual cluster to
	// the host cluster. If this is enabled someone within the virtual cluster will be
	// able to change the labels and taints of the host cluster node.
	SyncBackChanges *bool `json:"syncBackChanges,omitempty" yaml:"syncBackChanges,omitempty" mapstructure:"syncBackChanges,omitempty"`
}

type SyncPods struct {
	// Enabled defines if pod syncing should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// EnforceTolerations will add the specified tolerations to all pods synced by the
	// virtual cluster.
	EnforceTolerations []string `json:"enforceTolerations,omitempty" yaml:"enforceTolerations,omitempty" mapstructure:"enforceTolerations,omitempty"`

	// RewriteHosts is a special option needed to rewrite statefulset containers to
	// allow the correct FQDN. virtual cluster will add
	// a small container to each stateful set pod that will initially rewrite the
	// /etc/hosts file to match the FQDN expected by
	// the virtual cluster.
	RewriteHosts *SyncRewriteHosts `json:"rewriteHosts,omitempty" yaml:"rewriteHosts,omitempty" mapstructure:"rewriteHosts,omitempty"`

	// TranslateImage maps an image to another image that should be used instead. For
	// example this can be used to rewrite
	// a certain image that is used within the virtual cluster to be another image on
	// the host cluster
	TranslateImage SyncPodsTranslateImage `json:"translateImage,omitempty" yaml:"translateImage,omitempty" mapstructure:"translateImage,omitempty"`

	// UseSecretsForSATokens will use secrets to save the generated service account
	// tokens by virtual cluster instead of using a
	// pod annotation.
	UseSecretsForSATokens *bool `json:"useSecretsForSATokens,omitempty" yaml:"useSecretsForSATokens,omitempty" mapstructure:"useSecretsForSATokens,omitempty"`
}

// TranslateImage maps an image to another image that should be used instead. For
// example this can be used to rewrite
// a certain image that is used within the virtual cluster to be another image on
// the host cluster
type SyncPodsTranslateImage map[string]string

type SyncRewriteHosts struct {
	// Enabled specifies if rewriting stateful set pods should be enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// InitContainer holds extra options for the init container used by vCluster to
	// rewrite the FQDN for stateful set pods.
	InitContainer *SyncRewriteHostsInitContainer `json:"initContainer,omitempty" yaml:"initContainer,omitempty" mapstructure:"initContainer,omitempty"`
}

type SyncRewriteHostsInitContainer struct {
	// Image is the image virtual cluster should use to rewrite this FQDN.
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Resources are the resources that should be assigned to the init container for
	// each stateful set init container.
	Resources *Resources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`
}

type SyncToHost struct {
	// ConfigMaps defines if config maps created within the virtual cluster should get
	// synced to the host cluster.
	ConfigMaps *SyncAllResource `json:"configMaps,omitempty" yaml:"configMaps,omitempty" mapstructure:"configMaps,omitempty"`

	// Endpoints defines if endpoints created within the virtual cluster should get
	// synced to the host cluster.
	Endpoints *EnableSwitch `json:"endpoints,omitempty" yaml:"endpoints,omitempty" mapstructure:"endpoints,omitempty"`

	// Ingresses defines if ingresses created within the virtual cluster should get
	// synced to the host cluster.
	Ingresses *EnableSwitch `json:"ingresses,omitempty" yaml:"ingresses,omitempty" mapstructure:"ingresses,omitempty"`

	// NetworkPolicies defines if network policies created within the virtual cluster
	// should get synced to the host cluster.
	NetworkPolicies *EnableSwitch `json:"networkPolicies,omitempty" yaml:"networkPolicies,omitempty" mapstructure:"networkPolicies,omitempty"`

	// PersistentVolumeClaims defines if persistent volume claims created within the
	// virtual cluster should get synced to the host cluster.
	PersistentVolumeClaims *EnableSwitch `json:"persistentVolumeClaims,omitempty" yaml:"persistentVolumeClaims,omitempty" mapstructure:"persistentVolumeClaims,omitempty"`

	// PersistentVolumes defines if persistent volumes created within the virtual
	// cluster should get synced to the host cluster.
	PersistentVolumes *EnableSwitch `json:"persistentVolumes,omitempty" yaml:"persistentVolumes,omitempty" mapstructure:"persistentVolumes,omitempty"`

	// PodDisruptionBudgets defines if pod disruption budgets created within the
	// virtual cluster should get synced to the host cluster.
	PodDisruptionBudgets *EnableSwitch `json:"podDisruptionBudgets,omitempty" yaml:"podDisruptionBudgets,omitempty" mapstructure:"podDisruptionBudgets,omitempty"`

	// Pods defines if pods created within the virtual cluster should get synced to
	// the host cluster.
	Pods *SyncPods `json:"pods,omitempty" yaml:"pods,omitempty" mapstructure:"pods,omitempty"`

	// PriorityClasses defines if priority classes created within the virtual cluster
	// should get synced to the host cluster.
	PriorityClasses *EnableSwitch `json:"priorityClasses,omitempty" yaml:"priorityClasses,omitempty" mapstructure:"priorityClasses,omitempty"`

	// Secrets defines if secrets created within the virtual cluster should get synced
	// to the host cluster.
	Secrets *SyncAllResource `json:"secrets,omitempty" yaml:"secrets,omitempty" mapstructure:"secrets,omitempty"`

	// ServiceAccounts defines if service accounts created within the virtual cluster
	// should get synced to the host cluster.
	ServiceAccounts *EnableSwitch `json:"serviceAccounts,omitempty" yaml:"serviceAccounts,omitempty" mapstructure:"serviceAccounts,omitempty"`

	// Services defines if services created within the virtual cluster should get
	// synced to the host cluster.
	Services *EnableSwitch `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// StorageClasses defines if storage classes created within the virtual cluster
	// should get synced to the host cluster.
	StorageClasses *EnableSwitch `json:"storageClasses,omitempty" yaml:"storageClasses,omitempty" mapstructure:"storageClasses,omitempty"`

	// VolumeSnapshots defines if volume snapshots created within the virtual cluster
	// should get synced to the host cluster.
	VolumeSnapshots *EnableSwitch `json:"volumeSnapshots,omitempty" yaml:"volumeSnapshots,omitempty" mapstructure:"volumeSnapshots,omitempty"`
}

type Telemetry struct {
	// Enabled specifies that the telemetry for the vCluster control plane should be
	// enabled.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// InstanceCreator corresponds to the JSON schema field "instanceCreator".
	InstanceCreator *string `json:"instanceCreator,omitempty" yaml:"instanceCreator,omitempty" mapstructure:"instanceCreator,omitempty"`

	// MachineID corresponds to the JSON schema field "machineID".
	MachineID *string `json:"machineID,omitempty" yaml:"machineID,omitempty" mapstructure:"machineID,omitempty"`

	// PlatformInstanceID corresponds to the JSON schema field "platformInstanceID".
	PlatformInstanceID *string `json:"platformInstanceID,omitempty" yaml:"platformInstanceID,omitempty" mapstructure:"platformInstanceID,omitempty"`

	// PlatformUserID corresponds to the JSON schema field "platformUserID".
	PlatformUserID *string `json:"platformUserID,omitempty" yaml:"platformUserID,omitempty" mapstructure:"platformUserID,omitempty"`
}

type ValidatingWebhook struct {
	// AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
	// versions the Webhook expects.
	AdmissionReviewVersions []string `json:"admissionReviewVersions,omitempty" yaml:"admissionReviewVersions,omitempty" mapstructure:"admissionReviewVersions,omitempty"`

	// ClientConfig defines how to communicate with the hook.
	ClientConfig *ValidatingWebhookClientConfig `json:"clientConfig,omitempty" yaml:"clientConfig,omitempty" mapstructure:"clientConfig,omitempty"`

	// FailurePolicy defines how unrecognized errors from the admission endpoint are
	// handled -
	// allowed values are Ignore or Fail. Defaults to Fail.
	FailurePolicy *string `json:"failurePolicy,omitempty" yaml:"failurePolicy,omitempty" mapstructure:"failurePolicy,omitempty"`

	// MatchConditions is a list of conditions that must be met for a request to be
	// sent to this
	// webhook. Match conditions filter requests that have already been matched by the
	// rules,
	// namespaceSelector, and objectSelector. An empty list of matchConditions matches
	// all requests.
	// There are a maximum of 64 match conditions allowed.
	MatchConditions []interface{} `json:"matchConditions,omitempty" yaml:"matchConditions,omitempty" mapstructure:"matchConditions,omitempty"`

	// matchPolicy defines how the "rules" list is used to match incoming requests.
	// Allowed values are "Exact" or "Equivalent".
	MatchPolicy *string `json:"matchPolicy,omitempty" yaml:"matchPolicy,omitempty" mapstructure:"matchPolicy,omitempty"`

	// The name of the admission webhook.
	// Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
	// "imagepolicy" is the name of the webhook, and kubernetes.io is the name
	// of the organization.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// NamespaceSelector decides whether to run the webhook on an object based
	// on whether the namespace for that object matches the selector. If the
	// object itself is a namespace, the matching is performed on
	// object.metadata.labels. If the object is another cluster scoped resource,
	// it never skips the webhook.
	NamespaceSelector interface{} `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// ObjectSelector decides whether to run the webhook based on if the
	// object has matching labels. objectSelector is evaluated against both
	// the oldObject and newObject that would be sent to the webhook, and
	// is considered to match if either object matches the selector.
	ObjectSelector interface{} `json:"objectSelector,omitempty" yaml:"objectSelector,omitempty" mapstructure:"objectSelector,omitempty"`

	// Rules describes what operations on what resources/subresources the webhook
	// cares about.
	// The webhook cares about an operation if it matches _any_ Rule.
	Rules []interface{} `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// SideEffects states whether this webhook has side effects.
	SideEffects *string `json:"sideEffects,omitempty" yaml:"sideEffects,omitempty" mapstructure:"sideEffects,omitempty"`

	// TimeoutSeconds specifies the timeout for this webhook.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// ValidatingWebhookClientConfig contains the information to make a TLS connection
// with the webhook
type ValidatingWebhookClientConfig struct {
	// CABundle is a PEM encoded CA bundle which will be used to validate the
	// webhook's server certificate.
	// If unspecified, system trust roots on the apiserver are used.
	CaBundle *string `json:"caBundle,omitempty" yaml:"caBundle,omitempty" mapstructure:"caBundle,omitempty"`

	// Service is a reference to the service for this webhook. Either
	// `service` or `url` must be specified.
	//
	// If the webhook is running within the cluster, then you should use `service`.
	Service *ValidatingWebhookServiceReference `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// URL gives the location of the webhook, in standard URL form
	// (`scheme://host:port/path`). Exactly one of `url` or `service`
	// must be specified.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

type ValidatingWebhookConfiguration struct {
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" mapstructure:"apiVersion,omitempty"`

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// Standard object metadata; More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.
	Metadata *ObjectMeta `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Webhooks is a list of webhooks and the affected resources and operations.
	Webhooks []ValidatingWebhook `json:"webhooks,omitempty" yaml:"webhooks,omitempty" mapstructure:"webhooks,omitempty"`
}

type ValidatingWebhookServiceReference struct {
	// Name is the name of the service.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace is the namespace of the service.
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Path is an optional URL path which will be sent in any request to
	// this service.
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// If specified, the port on the service that hosting webhook.
	// Default to 443 for backward compatibility.
	// `port` should be a valid port number (1-65535, inclusive).
	Port *int `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

type VirtualClusterKubeConfig struct {
	// ServerCAKey is the client ca cert path.
	ClientCACert *string `json:"clientCACert,omitempty" yaml:"clientCACert,omitempty" mapstructure:"clientCACert,omitempty"`

	// KubeConfig is the virtual cluster kubeconfig path.
	KubeConfig *string `json:"kubeConfig,omitempty" yaml:"kubeConfig,omitempty" mapstructure:"kubeConfig,omitempty"`

	// RequestHeaderCACert is the request header ca cert path.
	RequestHeaderCACert *string `json:"requestHeaderCACert,omitempty" yaml:"requestHeaderCACert,omitempty" mapstructure:"requestHeaderCACert,omitempty"`

	// ServerCAKey is the server ca cert path.
	ServerCACert *string `json:"serverCACert,omitempty" yaml:"serverCACert,omitempty" mapstructure:"serverCACert,omitempty"`

	// ServerCAKey is the server ca key path.
	ServerCAKey *string `json:"serverCAKey,omitempty" yaml:"serverCAKey,omitempty" mapstructure:"serverCAKey,omitempty"`
}

type VolumeClaim struct {
	// AccessModes are the persistent volume claim access modes.
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Enabled enables deploying a persistent volume claim. If auto, vCluster will
	// automatically determine
	// based on the chosen distro and other options if this is required.
	Enabled interface{} `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// RetentionPolicy is the persistent volume claim retention policy.
	RetentionPolicy *string `json:"retentionPolicy,omitempty" yaml:"retentionPolicy,omitempty" mapstructure:"retentionPolicy,omitempty"`

	// Size is the persistent volume claim storage size.
	Size *string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// StorageClass is the persistent volume claim storage class.
	StorageClass *string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// VolumeMount describes a mounting of a Volume within a container.
type VolumeMount struct {
	// Path within the container at which the volume should be mounted.  Must
	// not contain ':'.
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// mountPropagation determines how mounts are propagated from the host
	// to container and the other way around.
	// When not set, MountPropagationNone is used.
	// This field is beta in 1.10.
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// This must match the Name of a Volume.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Mounted read-only if true, read-write otherwise (false or unspecified).
	// Defaults to false.
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// Path within the volume from which the container's volume should be mounted.
	// Defaults to "" (volume's root).
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// Expanded path within the volume from which the container's volume should be
	// mounted.
	// Behaves similarly to SubPath but environment variable references $(VAR_NAME)
	// are expanded using the container's environment.
	// Defaults to "" (volume's root).
	// SubPathExpr and SubPath are mutually exclusive.
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}
